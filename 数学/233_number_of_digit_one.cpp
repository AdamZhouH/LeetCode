#include <vector>
#include <string>
#include <iostream>
using namespace std;

class Solution {
public:
    int countDigitOne(int n);
};

// 找规律题，求出每一位能够出现1的个数，然后把他们相加即可
// 考虑在某一个位上出现1的次数，可能和其高位数字、低位数字、本身都有关系
// 分析个位
// 1.如果个位上数字为0，那么这个位上出现的1的次数只和高位相关
//   自己可以举例子，比如2410，那么个位出现1只能是1 11 21 - 2401，一共(2401-1)/10+1=241个
// 2.如果个位为1，比如2411，那么个位出现1可能是1 11 -2401 2411一共241+1=242 个
// 3.如果个位大于1，比如2418，那个位为1，则为1 11 - 2401 2411，一共242个
// 这里可能还没有明显的相互影响的关系，继续分析
// 分析考虑一个更高位的，比如百位的1出现的情况
// 1.如果百位为0，比如23014，那么百位为1的数字有100-199 1100-1199 2100-2199 22100-22199
//   一共((22100-100)/1000+1)*100=23*100=2300个
// 2.如果百位为1，比如23114，那么百位出现1的数字有100-199 ..22100-22199 23100-23114
//   此时可以发现出现的次数和高位地位都有关系，一共有((22100-100)/1000+1)*100 + 114+1=23*100+115个
// 3.如果百位大于1，比如23514，那么百位出现1的数字有100-199 ...23100-23199
//   一共有((23100-100)/1000+1)*100=24*100=2400个，显然只和高位数字有关
// 综合上述可发现规律，然后针对每一个位求解出现1的次数即可
// 计算时候，每次迭代只要保存左侧数字和右侧数字即可，然后根据当前位的情况分别计算

// 从个位开始计数
int Solution::countDigitOne(int n) {
    if (n <= 0) return 0;
    int ans = 0;
    int len = 0;
    int tmp = n;
    while (tmp) { len++; tmp /= 10;}
    int rpart = 0, lpart = n / 10;
    int rbit = 0;
    while (n) {
        int curr = n % 10;
        if (curr == 0) {
            ans += lpart * pow(10, rbit);
        } else if (curr == 1) {
            ans += lpart * pow(10, rbit) + rpart + 1;
        } else {
            ans += (lpart + 1) * pow(10, rbit);
        }
        lpart /= 10, rpart += curr * pow(10, rbit), rbit++;
        n /= 10;
    }
    return ans;
}
