#include <vector>
using namespace std;

// 开始想递归或者广搜那么可能导致内存爆掉，因为树的层数很大，某层的数字太多
// 由于从开始这个数字出发，只能*2或者-1，并且不能/，其实可以考虑贪心思路
// 如果当前值比y大，那么直接减到Y
// 如果比y小，不能无脑倍增，然后超过之后开始减，因为有可能倍增的间隙太大，导致减
// 法需要做太多次，而如果先退回到一个更小的数字，然后倍增，之后要做的减法可能少很多
// 因此这里需要做权衡
// 其实，如果从逆向思维角度考虑，y到达x，那么y只能/2或者+1
// 当y为奇数，毫无疑问，只能+1
// 当y为偶数，两种选择，但其实直接/2是最佳，假如y先+1到某个数字再/2
// 其实通过先直接/2，然后+更少的数字就可以走到，比如当前y为14，要走到9
// 那么14先+4再/2，一共5步，但是先/2，然后+2，一共3步
// 综上可以得到解法
class Solution {
public:
    int brokenCalc(int X, int Y) {
        int cnt = 0;
        while (Y != X) {
            if (Y <= X) { cnt += X-Y; break; }
            if (Y % 2) Y++;
            else Y /= 2;
            cnt++;
        }
        return cnt;
    }
};